# -*- coding: utf-8 -*-
"""Deepfake_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zFbQWWbnn4cm3pS5Ke48X8bipW-tto8-

# Import Libraries
"""



import streamlit as st
import torch
import torch.nn.functional as F
from facenet_pytorch import MTCNN, InceptionResnetV1
import numpy as np
from PIL import Image
import cv2
from pytorch_grad_cam import GradCAM
from pytorch_grad_cam.utils.model_targets import ClassifierOutputTarget
from pytorch_grad_cam.utils.image import show_cam_on_image
import warnings
import requests
from io import BytesIO
warnings.filterwarnings("ignore")



st.set_page_config(page_title="Deepfake Detection",
                   layout="wide",
                   page_icon="üßë‚Äç‚öïÔ∏è")


input_image = st.file_uploader("Choose an image to detect Real or Fake.......", type=['png','jpg','jpeg'])

try:
    image = Image.open(input_image)  # Open the uploaded image using PIL(pillow library)
    st.image(image, caption="Image uploded Successfully",  width=250)
except Exception as e:
    st.info("No Face is detected, Please Upload valid image.....")

if input_image is not None:

    DEVICE = 'cuda:0' if torch.cuda.is_available() else 'cpu'

    mtcnn = MTCNN(
        select_largest=False,
        post_process=False,
        device=DEVICE
    ).to(DEVICE).eval()

    model = InceptionResnetV1(
        pretrained="vggface2",
        classify=True,
        num_classes=1,
        device=DEVICE
    )



    model_download_link = "https://drive.google.com/uc?export=download&id=137wNyE7NiEfPZ5D2p67aAK-U2-qwUPip"

    # Download the model file from the provided link
    response = requests.get(model_download_link)
    response.raise_for_status()  # Check for any errors during download

    # Load the model from the downloaded content
    checkpoint = torch.load(BytesIO(response.content), map_location=torch.device('cpu'))
    model.load_state_dict(checkpoint['model_state_dict'])
    model.to(DEVICE)
    model.eval()



    def predict(input_image:Image.Image):
        face = mtcnn(input_image)
        if face is None:
            raise Exception('No face detected')
        face = face.unsqueeze(0) # add the batch dimension
        face = F.interpolate(face, size=(256, 256), mode='bilinear', align_corners=False)

        # convert the face into a numpy array to be able to plot it
        prev_face = face.squeeze(0).permute(1, 2, 0).cpu().detach().int().numpy()
        prev_face = prev_face.astype('uint8')

        face = face.to(DEVICE)
        face = face.to(torch.float32)
        face = face / 255.0
        face_image_to_plot = face.squeeze(0).permute(1, 2, 0).cpu().detach().int().numpy()

        target_layers=[model.block8.branch1[-1]]
        use_cuda = True if torch.cuda.is_available() else False
        cam = GradCAM(model=model, target_layers=target_layers, use_cuda=use_cuda)
        targets = [ClassifierOutputTarget(0)]

        grayscale_cam = cam(input_tensor=face, targets=targets, eigen_smooth=True)
        grayscale_cam = grayscale_cam[0, :]
        visualization = show_cam_on_image(face_image_to_plot, grayscale_cam, use_rgb=True)
        # face_with_mask = cv2.addWeighted(prev_face, 1, visualization, 0.5, 0)


        face_with_mask = np.array(Image.fromarray(face_image_to_plot).convert('RGB').resize((prev_face.shape[1], prev_face.shape[0])))

        face_with_mask = (prev_face.astype(float) + visualization.astype(float)) / 2


        with torch.no_grad():
            output = torch.sigmoid(model(face).squeeze(0))
            prediction = "real" if output.item() < 0.5 else "fake"

            real_prediction = 1 - output.item()
            fake_prediction = output.item()

            confidences = {
                'real': real_prediction,
                'fake': fake_prediction
            }
        return confidences, face_with_mask

    if input_image is not None:
        if(st.button("Click Here To See Result")):
            try:
                confidences, face_with_mask = predict(image)
                output_image = Image.fromarray(face_with_mask)
                st.image(output_image, width=250)
                # Display the confidence values separately
                st.success(f"Confidences: Real - {confidences['real'] * 100:.2f}%, Fake - {confidences['fake'] * 100:.2f}%")
            except Exception as e:
                st.error(str(e))







